---
layout:     post             				# 使用的布局（不需要改）
title:        MySQL系列：行锁、死锁    # 标题 
subtitle:    					  				#副标题
date:       2021-10-05  					# 时间
author:     阿琦                  			# 作者
header-img: img/home-bg-o.jpg 	#这篇文章标题背景图片
catalog: true                        	# 是否归档
istop:  false                             # 是否置顶
iscopyright: true                      # 是否版权，默认有
music-id:                                        # 网易云音乐单曲嵌入
music-idfull:                               # 网易云音乐歌单嵌入
apserver:                           # 音乐平台netease/tencent/kugou/xiami/baidu
aptype:     	           		# 音乐类型song/playlist/album/search/artist
apsongid:                    # 音乐song/playlist/album id
tags:                              	           	#标签
    - 自我总结
    - DB
---

&nbsp;
&nbsp;

<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; counter-reset: counterh1 counterh2 counterh3;"><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">1</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">前言</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">前两天去富阳考科三科四去了，虽然已当场拿到驾照，但如果再让我来一次，那肯定不选手动挡了。</p>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">现在的车都是自动挡的</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">自动挡好考</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">练手动挡你会感觉请了个人天天来 diss 你，而且你还不能还嘴</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果没特殊需求，根本没必要考手动挡，如有意见参考第 1 条</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">杭州驾校有隐形收费，最好事先咨询好</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">没了，以上只供参考</section></li></ol>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">2</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">目录</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">行锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">行锁对性能的影响</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">两阶段锁(2pc)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">死锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">死锁检测</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何最小化和处理死锁</section></li></ul>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">3</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">继续</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">上一篇：<a href="https://mp.weixin.qq.com/s/ntowxAaYh8pWpaQhBf69jw" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">MySQL系列：全局锁、表锁</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">mysql 行锁是在引擎层各个引擎自己实现的<a href="https://mp.weixin.qq.com/s/uVSWWLF1_JQSdPfPuvrJ9A" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">MySQL系列：一条 sql 语句是如何执行的</a>。但并不是所有的引擎都支持行锁，比如 mysql 老版本默认的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">MyISAM 引擎就不支持行锁</code>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务的并发度。InnoDB 是支持行锁的，这也是取代 MyISAM 的重要原因之一。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">行锁</code>是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时事务 B 也要更新同一行，那么必须等事务 A 操作完成后才能更新。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">4</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">两阶段锁</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">栗子，假设字段 id 是表 aqi 的主键，事务 B 的 update 语句执行时会发生什么。</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://ian-upic.oss-cn-hangzhou.aliyuncs.com/uPic/y5Uqg6.png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border: 1px dashed rgb(37,132,181); background: transparent;">
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">begin 开始一个事务</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">rollback 事务回滚</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">commit 事务确认</section></li></ul>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">A 持有两个记录的行锁，都是在 commit 的时候才释放的。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">看了下官方文档 8.0 版，还有个 Phantom Rows ？？大概意思是当同一个查询在不同时间产生不同的行集时，Phantom Rows 就会发生在一个事务中。例如，如果 SELECT 被执行两次，但第二次返回第一次没有返回的行，则该行是“幻影”行。</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://files.mdnice.com/user/10345/627e3d30-8f72-412e-aa8c-2f7a2eba23ad.png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">完整官网说明：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设，你负责实现一个电影票的在线交易业务，顾客 A 要在电影院 B 购买电影票，简化后的业务如下几点：</p>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从顾客 A 账号余额中扣除电影票价；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">给影院 B 的账号余额增加这张电影票价；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">记录一条交易日志；</section></li></ol>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">要完成这个交易，需要 update 两条记录，并 insert 一条记录。为了保证交易的原子性，要把这三个操作放在一个事务中。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">根据两阶段锁协议，无论怎样的顺序，所有操作需要的行锁都是在事务提交的时候才释放。所以，如果把语句 2 放到最后，比如 3、1、2 这样，那么影院账号余额这一行的锁时间就最少。就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">但是这个设计是有缺陷的，比如：这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，mysql 就挂了。<a href="https://mp.weixin.qq.com/s/EqIreNAPfMakm06-dH-toQ" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">线上问题定位常用命令</a>服务器三连，发现 CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务，这里就要说死锁了。</p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border: 1px dashed rgb(37,132,181); background: transparent;">
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">QPS：Queries Per Second 意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border: 1px dashed rgb(37,132,181); background: transparent;">
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">TPS: TransactionsPerSecond 的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器 做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使 用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体 TPS 得分。</p>
</blockquote>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">5</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">死锁、死锁检测</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程进入无限等待的状态，称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">死锁</code>。</strong></p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://ian-upic.oss-cn-hangzhou.aliyuncs.com/uPic/2v0kTE.png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。事务 A 和事务 B 都在互相等待对方的资源释放，这就进入了死锁的状态。当出现死锁以后，有两种策略：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_lock_wait_timeout</code>来设置。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">第二种策略是，发起死锁检测，检测到死锁后，主动回滚死锁链条中的某个事物，让其他事物得以继续执行。将参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_deadlock_delect</code>设置为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">on</code>，表示开启这个逻辑。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在 innodb 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于一个在线服务来说，这个等待时间往往是无法接受的。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">但如果把这个时间设置成一个很小的值，又会有误伤。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">所以正常情况下一般采用第二种策略 -- 主动死锁检测，而且 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_deadlock_detect</code> 默认 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">on</code> 。主动检测发生死锁时，是能够快速发现并进行处理的，但它也有额外负担。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">按照上面第二种的话，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待 -- 死锁。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">那么每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n)的操作。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是期间要消耗大量的 CPU 资源。因此，就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">这种热点行更新导致的性能问题症结在于，死锁检测要耗费大量的 CPU 资源，解决策略有以下几种:</p>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">降低并发度</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">拆行，一行拆多行</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Server 层限流，即同一时间进入更新的线程数</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关闭死锁监测（关闭的弊端是可能超时较多）</section></li></ol>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">一种头痛医头的办法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong> 但是这种操作本身带有一定风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">另一个思路是控制并发度。</strong> 根据上面的分析，会发现如果并发能够控制住的话，比如同一行同时最多只能有 10 个线程在更新，那么死锁检测的成本就会很低，也就不会出现这个问题。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">一个直接的想法就是，在客户端做并发控制。但你很快就会发现这个方法不太行，因为客户端很多，比如一个应用，有几百个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到上千或者几千。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">因此，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">这个并发控制要做在数据库服务端</code>。如果有中间件，可以考虑在中间件实现；如果有 DBA .. . 基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 Innodb 内部就不会有大量的死锁检测工作了。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">6</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">MySQL8.0 官方文档</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">官方文档InnoDB 死锁示例：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-example.html" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-example.html</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">首先，客户端 A 创建一个包含一行的表，然后开始一个事务。在事务中，A 通过S在共享模式下选择该行来获得该行的 锁定：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">CREATE</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TABLE</span>&nbsp;t&nbsp;(i&nbsp;<span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;">INT</span>)&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">ENGINE</span>&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">InnoDB</span>;<br>Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(1.07&nbsp;sec)<br><br>mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">INSERT</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">INTO</span>&nbsp;t&nbsp;(i)&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">VALUES</span>(<span class="hljs-number" style="color: #d19a66; line-height: 26px;">1</span>);<br>Query&nbsp;OK,&nbsp;1&nbsp;row&nbsp;affected&nbsp;(0.09&nbsp;sec)<br><br>mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">START</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TRANSACTION</span>;<br>Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.00&nbsp;sec)<br><br>mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">SELECT</span>&nbsp;*&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">FROM</span>&nbsp;t&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">WHERE</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number" style="color: #d19a66; line-height: 26px;">1</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">FOR</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">SHARE</span>;<br>+<span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;">------+</span><br>|&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;|<br>+<span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;">------+</span><br>|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;|<br>+<span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;">------+</span><br><br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">接下来，客户端 B 开始一个事务并尝试从表中删除该行：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">START</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TRANSACTION</span>;<br>Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.00&nbsp;sec)<br><br>mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">DELETE</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">FROM</span>&nbsp;t&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">WHERE</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number" style="color: #d19a66; line-height: 26px;">1</span>;<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">删除操作需要X锁。无法授予S锁定，因为它与客户端 A 持有的锁定不兼容 ，因此请求进入行和客户端 B 块的锁定请求队列。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">最后，客户端 A 还尝试从表中删除该行：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">mysql&gt;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">DELETE</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">FROM</span>&nbsp;t&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">WHERE</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number" style="color: #d19a66; line-height: 26px;">1</span>;<br>ERROR&nbsp;1213&nbsp;(40001):&nbsp;Deadlock&nbsp;found&nbsp;when&nbsp;trying&nbsp;to&nbsp;get&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">lock</span>;<br>try&nbsp;restarting&nbsp;transaction<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">这里发生死锁是因为客户端 A 需要一个 X锁来删除该行。但是，该锁定请求无法被授予，因为客户端 B 已经有一个X锁定请求并且正在等待客户端 A 释放其S锁定。SA 持有的锁也不能 X因为 B 先前的X锁请求而升级 为锁。结果， InnoDB为其中一个客户端生成错误并释放其锁。客户端返回此错误：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">ERROR&nbsp;1213&nbsp;(40001):&nbsp;Deadlock&nbsp;found&nbsp;when&nbsp;trying&nbsp;to&nbsp;get&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">lock</span>;<br>try&nbsp;restarting&nbsp;transaction<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">此时，可以授予另一个客户端的锁定请求，并从表中删除该行。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">官方文档死锁检测：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">当启用死锁检测（默认）时， InnoDB自动检测事务 死锁并回滚一个或多个事务以打破死锁。 InnoDB尝试选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">InnoDB知道表锁 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">if innodb_table_locks = 1（默认）</code>和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">autocommit = 0</code>，并且它上面的 MySQL 层知道行级锁。否则， InnoDB无法检测死锁，其中涉及由 MySQLLOCK TABLES 语句设置的表锁或由非存储引擎设置的锁 InnoDB。通过设置<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_lock_wait_timeout</code>系统变量的值来解决这些情况 。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果Monitor 输出LATEST DETECTED DEADLOCK部分 InnoDB包含一条消息，说明TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL BACK FOLLOWING TRANSACTION，这表明等待列表中的事务数已达到 200 的限制. 超过 200 个事务的等待列表被视为死锁，尝试检查等待列表的事务将被回滚。如果锁定线程必须查看等待列表上的事务拥有的 1,000,000 个以上的锁，也可能发生相同的错误。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">禁用死锁检测</strong>：
在高并发系统上，当大量线程等待同一个锁时，死锁检测会导致速度减慢。有时，禁用死锁检测并在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_lock_wait_timeout</code> 发生死锁时依赖事务回滚设置可能更有效 。可以使用该<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_deadlock_detect</code> 变量禁用死锁检测 。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">官方文档 如何最小化和处理死锁：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">死锁是事务数据库中的一个经典问题，但它们并不危险，除非它们非常频繁以至于根本无法运行某些事务。通常，必须编写应用程序，以便它们随时准备在事务因死锁回滚时重新发出事务。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">InnoDB使用自动行级锁定。即使在仅插入或删除单行的事务的情况下，也可能会遇到死锁。那是因为这些操作并不是真正的“原子”；它们会自动对插入或删除的行的（可能是多个）索引记录设置锁定。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">可以使用以下技术处理死锁并降低其发生的可能性：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在任何时候，发出 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">SHOW ENGINE INNODB STATUS</code>以确定最近死锁的原因。这可以帮助调整应用程序以避免死锁。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果频繁的死锁警告引起关注，请通过启用该<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">innodb_print_all_deadlocks</code>变量来收集更广泛的调试信息 。有关每个死锁的信息，而不仅仅是最新的，都记录在 MySQL 错误日志中。完成调试后禁用此选项。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果由于死锁而失败，请随时准备重新发出事务。死锁并不危险。再试一次。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">保持事务小且持续时间短，以减少它们发生冲突的可能性。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在进行一组相关更改后立即提交事务，以减少它们发生冲突的可能性。特别是，不要让交互式 mysql会话长时间处于打开状态并带有未提交的事务。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果使用锁定读取<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">（SELECT ... FOR UPDATE或 SELECT ... FOR SHARE）</code>，请尝试使用较低的隔离级别，例如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">READ COMMITTED</code>。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">当修改一个事务中的多个表或同一个表中的不同行集时，每次都以一致的顺序执行这些操作。然后事务形成明确定义的队列并且不会死锁。例如，组织数据库操作到功能在应用程序中，或调用存储程序，而不是编码的多个相似序列<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">INSERT</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">UPDATE</code>以及 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">DELETE</code>在不同的地方语句。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">将精心挑选的索引添加到表中，以便查询扫描更少的索引记录并设置更少的锁。使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">EXPLAIN SELECT</code>以确定哪些索引MySQL认为最适合查询。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">使用较少的锁定。如果可以允许 a SELECT从旧快照返回数据，请不要向其添加<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">FOR UPDATEor FOR SHARE</code>子句。在READ COMMITTED这里使用 隔离级别很好，因为同一事务中的每个一致性读取都从它自己的新快照中读取。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果没有其他帮助，请使用表级锁序列化事务。使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">LOCK TABLES</code>事务表（例如InnoDB 表）的正确方法是使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">SET autocommit = 0(not START TRANSACTION)</code>后跟开始事务<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">LOCK TABLES</code>，并且<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">UNLOCK TABLES</code>在明确提交事务之前不调用 。例如，如果需要写入 table t1并从 table 读取 t2，可以这样做：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;"><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">SET</span>&nbsp;autocommit=<span class="hljs-number" style="color: #d19a66; line-height: 26px;">0</span>;<br><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">LOCK</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TABLES</span>&nbsp;t1&nbsp;WRITE,&nbsp;t2&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">READ</span>,&nbsp;...;<br>...&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">do</span>&nbsp;something&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">with</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">tables</span>&nbsp;t1&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">and</span>&nbsp;t2&nbsp;here&nbsp;...<br><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">COMMIT</span>;<br><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">UNLOCK</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TABLES</span>;<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">表级锁可防止对表的并发更新，从而避免死锁，但代价是繁忙系统的响应速度变慢。</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">序列化事务的另一种方法是创建一个仅包含一行的辅助“信号量”表。让每个事务在访问其他表之前更新该行。这样，所有事务都以串行方式发生。请注意，InnoDB 即时死锁检测算法也适用于这种情况，因为序列化锁是行级锁。对于 MySQL 表级锁，必须使用超时方法来解决死锁。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">MySQL官网死锁这块目录：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html</a></p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://ian-upic.oss-cn-hangzhou.aliyuncs.com/uPic/WhfAoW.png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
</section>


