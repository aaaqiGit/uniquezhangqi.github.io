---
layout:     post             				# 使用的布局（不需要改）
title:       MySQL系列：索引(上)  # 标题 
subtitle:    					  				#副标题
date:       2021-10-05  					# 时间
author:     阿琦                  			# 作者
header-img: img/home-bg-o.jpg 	#这篇文章标题背景图片
catalog: true                        	# 是否归档
istop:  false                             # 是否置顶
iscopyright: true                      # 是否版权，默认有
music-id:                                        # 网易云音乐单曲嵌入
music-idfull:                               # 网易云音乐歌单嵌入
apserver:                           # 音乐平台netease/tencent/kugou/xiami/baidu
aptype:     	           		# 音乐类型song/playlist/album/search/artist
apsongid:                    # 音乐song/playlist/album id
tags:                              	           	#标签
    - 自我总结
    - DB
---

&nbsp;
&nbsp;


<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; counter-reset: counterh1 counterh2 counterh3;"><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">1</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">继续</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">上一篇: <a href="https://mp.weixin.qq.com/s/BNTdcS7AmieztRw5L8Gn3w" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(37,132,181); border-bottom: 1px solid rgb(37,132,181);">MySQL系列：事务隔离</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">索引，说到索引 一般遇到某条 sql 查询比较慢，然后说加个索引吧之类的解决方案。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">什么是索引？ 索引是如何工作的？</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">一句话简单来说，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">索引就是为了提高查询效率，就像书的目录一样</code>，根据目录能更快的找到自己想要的东西。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">2</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">索引的常见模型</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">索引是为了提高查询效率，但实现索引的方式有很多，有三种常见、也比较简单的数据结构，分别是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">哈希表</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">有序数组</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">搜索树</code>。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">哈希表是一种键 - 值（key-value）存储数据的结构，根据键 key，就可以找到其对应的值 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">多个 key 经过 hash 函数的计算，会出现同一个值的情况，处理这种问题的方法之一就是拉出一个链表。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">举例，假设，现在维护着一个身份信息和姓名表，需要根据身份证号查找对应的姓名，这时对应的 hash 索引如下图所示：</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtvmhdkzndj611y0o2dia02.jpg" alt="哈希表示意图" style="display: block; margin: 0 auto; max-width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">哈希表示意图</figcaption></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">图中user4 和 user2算出来的值都是n，但是没关系，后面跟了一个链表。假设你现在要查ID_card_n2对应的名字是什么，步骤就是先将ID_card_n2通过 hash 计算出 n，然后顺序遍历找到 user2。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">需要注意图中四个ID_card_n的值不是递增的，这样做的好处是新增 user 的速度会很快，只需要往后追加。缺点不是有序的，<strong style="font-weight: bold; color: rgb(37,132,181);">所以hash 做区间查询的速度是很慢的</strong>。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设现在要找身份证在[ID_card_x，ID_card_y]的所有用户，那么就要全部扫描一遍。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">所以哈希表这种结构只适合等值查询的场景。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">不过有序数组在等值查询和范围查询的场景中，性能都非常优秀</strong>。继续上面例子，假设用有序数组来实现的话，如下图：</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtvmhuwmkrj60zo0a8wfq02.jpg" alt="有序数组示意图" style="display: block; margin: 0 auto; max-width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">有序数组示意图</figcaption></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设身份证号没有重复，这个数组就是按照身份证号递增顺序保存的。这个时候如果你要查询ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">上面这个索引结构支持范围查询，如果要查询[ID_card_x，ID_card_y]区间的 user，先用二分法查找ID_card_x（如果不存在ID_card_x，就找大于ID_card_x的第一个 user），然后向右遍历，直到查到第一个大于ID_card_y 的身份证号，退出循环。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果仅仅看查询效率，有序数组就是最好的数据结构了。但是更新数据的时候就麻烦了，往中间插入一个记录就必须挪动后面的所有记录，成本太高。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">所以有序数组索引只适用于静态存储引擎</strong>。比如 配置文件这类，不需要怎么修改的数据。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">二叉树，一个经典的数据结构，如果用二叉树来实现上面的根据身份证号查询姓名的话，如下图所示：</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtvmjxzb79j61520o6mzx02.jpg" alt="二叉树示意图" style="display: block; margin: 0 auto; max-width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">二叉树示意图</figcaption></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">二叉搜索树的特点是，父节点左子树所有节点的值小于父节点的值，右子树所有节点的值大于父节点的值。</strong> 这时候要查ID_card_n2的话，按照图中搜索顺序就是按照userA -&gt; userC -&gt; userF -&gt; user2这个路径得到，时间复杂度是O(log(N))。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">维持复杂度O(log(N))，要保持这棵树是平衡二叉树，更新的时间复杂度也是O(log(N))。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，<strong style="font-weight: bold; color: rgb(37,132,181);">索引不止存在内存中，还要写到磁盘上。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">那么问题来了，如果一棵 100 万节点的平衡二叉树，树高 20。查询一次就需要需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储的话，单独访问一个行可能需要 20 个 10 ms 的时间，太慢了。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">所以为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，被广泛应用在数据库引擎中。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">3</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">InnoDB 的索引模型</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表叫<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">索引组织表</code>。InnoDB使用了B+树索引模型，所以数据都存在 B+树中。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">每个索引在InnoDB中都有一个颗对应的 B+树。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设，有一个主键列为 id 的表，表中有字段 k，并且在 k 上有索引。</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;"><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">CREATE</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">TABLE</span>&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">`aaaqi_demo4`</span><br>(<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">`id`</span>&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;">int</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">COMMENT</span>&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">'id'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">`k`</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;">int</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">NOT</span>&nbsp;<span class="hljs-literal" style="color: #56b6c2; line-height: 26px;">NULL</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">COMMENT</span>&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">'k'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">`name`</span>&nbsp;<span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #d19a66; line-height: 26px;">16</span>)&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">COMMENT</span>&nbsp;<span class="hljs-string" style="color: #98c379; line-height: 26px;">'name'</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">KEY</span>&nbsp;(<span class="hljs-string" style="color: #98c379; line-height: 26px;">`id`</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">INDEX</span>&nbsp;(k)<br>)&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">ENGINE</span>&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">InnoDB</span><br>&nbsp;&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">DEFAULT</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">CHARSET</span>&nbsp;=&nbsp;utf8mb4;<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">表中r1~r5的(id，k)值分别是(100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的如下图所示：</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtvml4kqdlj60w60egtam02.jpg" alt="InnoDB的索引组织结构" style="display: block; margin: 0 auto; max-width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">InnoDB的索引组织结构</figcaption></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">图中索引分为主键索引和非主键索引。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">主键索引的叶子节点存的是整行数据，在InnoDB中主键索引也叫聚簇索引。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">非主键索引叶子节点存的是主键的值，在InnoDB中非主键索引也叫二级索引。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">4</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">基于主键索引和普通索引的查询有什么区别？</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">sql：select * from T where id = 500,即主键查询方式，只需搜索id 这颗 B+树。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">sql：select * from T where k = 5,即普通索引查询方式，要先搜索 k 索引树，得到 id 值为 500 再到 id 索引树搜索一次，这个过程叫<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">回表</code>。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">也就是说非主键索引查询要多扫描一棵索引树。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">5</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">索引维护</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">B+ 树为了维护索引有序性，继续以上面图为例，如果插入新的行 id 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 id 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">更坏的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">页分裂</code>。在这种情况下，性能会受到影响。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">假设建表语句里一定要有自增主键，那么哪些场景下应该使用，哪些场景下不应该？</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">插入新记录的时候可以不指定 id 的值，系统会获取当前 id 最大值加 1 作为下一条记录的 id 值。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">也就是说，自增主键的插入数据模式，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">除了考虑性能外，还可以从存储空间的角度来看。假设表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键？</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">由于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; color: #1e6bb8; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all;">每个非主键索引的叶子节点上都是主键的值</code>。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: rgb(37,132,181);">主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果我非要用业务字段直接做主键行不行？</p>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gtvl9xzfa4g608w04eu0x02.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">只有一个索引；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">该索引必须是唯一索引。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">由于没有其他索引，那么也就不用考虑其他索引的叶子节点大小的问题。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: inline-block;"><span style="counter-increment: counterh2; color: rgb(159,205,208); border-bottom: 4px solid rgb(159,205,208); font-size: 18px; padding: 2px 4px;">6</span></span><span class="content" style="font-size: 18px; border-bottom: 4px solid rgb(37,132,181); padding: 2px 4px; color: rgb(37,132,181);">扩展</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">重建索引，比如 k 字段，sql可以这么写：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;"><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">alter</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">table</span>&nbsp;T&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">drop</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">index</span>&nbsp;k;<br><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">alter</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">table</span>&nbsp;T&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">add</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">index</span>(k);<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">如果要重建主键索引，sql可以这么写：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://files.mdnice.com/user/3441/876cad08-0422-409d-bb5a-08afec5da8ee.svg); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;"><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">alter</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">table</span>&nbsp;T&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">drop</span>&nbsp;primary&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">key</span>;<br><span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">alter</span>&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">table</span>&nbsp;T&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">add</span>&nbsp;primary&nbsp;<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">key</span>(<span class="hljs-keyword" style="color: #c678dd; line-height: 26px;">id</span>);<br></code></pre>
</section>