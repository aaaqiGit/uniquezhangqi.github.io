---
layout:     post             				# 使用的布局（不需要改）
title:      jvm系列(二)：内存区域与内存溢出   # 标题 
subtitle:    					  				#副标题
date:       2018-04-29  					# 时间
author:     Ian                  			# 作者
header-img: img/ian-bg-red.jpg	#这篇文章标题背景图片
catalog: true                        	# 是否归档
tags:                              		#标签
    - 编程之路
    - jvm
---

> 本文首次发布于[My Blog](http://uniquezhangqi.top),作者[@张琦(Ian)](http://uniquezhangqi.top/about/),转载请保留原文链接。

### 引言

Z 学一个东西都是按照下面的思路来的，所以写东西也是尽量会按照下面思路来，可能会和其它大佬不一样，毕竟现在Z 还是小菜鸟一只🤓

#### 比如：A

1. 为什么需要A
2. 什么是A
3. 怎么使用A 
4. 使用A时注意的问题
5.  A的应用领域
6.  A的优缺点

学完之后，问自己 ：是什么？为什么？怎么办？

### 正文

### 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。如下图“

![](https://ws3.sinaimg.cn/large/006tNc79gy1fqtbw9wl85j30gz0gagmf.jpg)

下面都是围绕这个图来讲。

### 程序计数器
#### 是什么
`程序计数器`是一块较小的内存空间，它可以看作是当前线程所执行的字节码的型号指示器。

#### 应用场景
`字节码解释器`工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

#### Java虚拟机多线程实现
Java 虚拟机的多线程 是通过线程轮流切换并分配处理器时间的方式来实现的。 在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。每条线程都需要有一个独立的`程序计数器`，各条线程之间计数器互不影响，独立存储， 这个内存区域叫“`线程私有`”的内存。

### Java虚拟机栈
#### 是什么
与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。**虚拟机栈描述的是Java方法执行的内存模型**：每个方法在执行的同时都会创建一个栈帧 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

现在所说的虚拟机栈或者说是虚拟机栈中局部变量表部分。

#### 局部变量表
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）在方法运行期间不会改变局部变量表的大小。

#### 异常状况

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
- 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为`虚拟机`执行Java方法（也就是）字节码服务，而`本地方法栈`则为虚拟机使用到的[Native方法服务](https://blog.csdn.net/wike163/article/details/6635321)。与虚拟机栈一样，会抛出StackOverflowError、OutOfMemoryError异常。

### Java堆
#### 什么是Java堆
Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。

在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。

#### 作用
Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”，现在垃圾收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代。

### 方法区
方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。

### 运行时常量池
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外 ，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。一般来说，除了保存Class文件中描述的`符号引用`外，还会把翻译出来的`直接引用`也存储在运行时常量池中。

#### 限制
运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 直接内存
本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息。有的大项目会配置，后面也会内存溢出会有截图。

### 对象的创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

- 假设Java堆中的内存是`绝对规整的`，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。这种分配方式称为“`指针碰撞`”。
- 如果Java堆中的内存并`不是规整的`,已使用的内存和空闲的内存相互交错，虚拟机就会必须维护一个列表，记录上哪些内存块是可用的，在分配的时候好从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“`空闲列表`”，

选择哪种分配方式都是由Java堆是否规整决定。--因此，**在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法**是指针碰撞，而是**用CMS这种基于Mark-Sweep算法的收集器时**，通常采用空闲列表。

#### 问题：
对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的一个位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来的及修改，对象B又同时使用了原来的指针来分配存储的情况。两种解决方案：

- 一种是对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
- 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为“`本地线程分配缓冲`”。

#### 对象的产生
上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看对象创建才刚刚开始--<init>方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new 指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域；`对象头`、`实例数据`、`对齐填充`。

#### 对象头
一共包括两部分信息：

- 第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。
- 第二部是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 实例数据
实例数据是对真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。

#### 对齐填充
对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用--对象的大小必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位
Java程序需要通过栈上的reference数据来操堆上的具体对象。目前主流的访问方式有**使用句柄**和**直接指针**：

- 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
- 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而erference中存储的直接就是对象地址。

#### 优缺点

- 使用句柄来访问的最大好处：就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要修改。
- 使用直接指针访问方式的最大好处：就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问载Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

虚拟机Sun HotSpot而言，使用的是第二种方式进行对象访问的。


### OutOfMemoryError异常
虚拟机启动参数，第一张Eclipse的，第二张是idea的。
![](https://ws2.sinaimg.cn/large/006tNc79gy1fqtlouyxcij31ec0ziwgr.jpg)
![](https://ws1.sinaimg.cn/large/006tNc79gy1fqtloxtzimj31kw14umyk.jpg)


### Java堆溢出
Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

解决这个区域异常，一般手段是先通过内存映像分析工具对Dump出来的堆转储快照进行分析。


**注：**<br>
reference： reference类型是一个指向对象的引用。


![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqj5aochgoj309k09kmwz.jpg)
<b><center>扫描关注：热爱生活的大叔</center>
<b><center><font size="2">（<font size="2" color="#FF0000">转载本站文章请注明作者和出处</font> <font size="2" color="#0000FF">热爱生活的大叔-uniquezhangqi</font><font size="2">）</font>
